// Generated by CoffeeScript 1.8.0
(function() {
  var USAGE, alphabetize, args, argv, async, command, exit, filePath, fs, getFiles, getPreSpaces, log, optimist, opts, path, processData, valid_selectors, value, writeToLine, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  async = require('async');

  optimist = require('optimist');

  path = require('path');

  filePath = path.join(__dirname, 'valid_selectors.json');

  valid_selectors = JSON.parse(fs.readFileSync(filePath, 'utf8'));

  USAGE = "Usage: styler <command> [command-specific-options]\n\nwhere <command> [command-specific-options] is one of:\n  alphabetizeStyle <path to stylus dir or file>\n  checkAlphabetized <path to stylus dir or file>\n  convertStyleToJson <path to stylus dir or file> (note need to > to json write to console)\n  inspectZValues <path to stylus dir or file>\n  normalizeZvalues <path to stylus dir or file>, [value to normalize on]\n  simple_lint <path to stylus dir or file>";

  argv = optimist.argv._;

  command = argv[0];

  args = argv.slice(1, argv.length);

  opts = optimist.argv;

  exit = function(msg) {
    if (msg) {
      log(msg);
    }
    return process.exit();
  };

  log = function(msg) {
    var c;
    c = console;
    return c.log(msg);
  };

  getPreSpaces = function(str) {
    return str.match(/^(\s)*/)[0].length;
  };

  writeToLine = function(file, line_str, line_num) {
    var data, end_line, file_str, line, line_number;
    data = fs.readFileSync(file, 'utf8');
    data = data.split('\n');
    file_str = '';
    for (line_number in data) {
      line = data[line_number];
      end_line = '';
      if (line_number === ("" + (line_num - 1))) {
        line = line_str;
      }
      if (("" + (data.length - 1)) !== line_number) {
        end_line = '\n';
      }
      file_str += "" + line + end_line;
    }
    return fs.writeFileSync(file, file_str, 'utf8');
  };

  alphabetize = function(data) {
    var arrayEqual, old_data;
    old_data = data.slice(0);
    data.sort();
    arrayEqual = function(a, b) {
      return a.length === b.length && a.every(function(elem, i) {
        return elem === b[i];
      });
    };
    return !arrayEqual(old_data, data);
  };

  getFiles = function(args, next) {
    var key, read_files, stats, val;
    if (!args.length) {
      return [];
    }
    stats = fs.statSync(args[0]);
    if (stats.isDirectory()) {
      read_files = fs.readdirSync(args[0]);
      for (key in read_files) {
        val = read_files[key];
        read_files[key] = args[0] + read_files[key];
      }
    } else if (stats.isFile()) {
      read_files = [args[0]];
    }
    return read_files;
  };

  processData = function(command, args) {
    var addError, alphabetizeCheck, arr, attr, attributeSet, attribute_info, breathing_room, buf, config, count, data, file, file_name, files, filesTotal, indent, index, infractions, join, line, line_num, line_number, obj, postJsonChecks, preJsonChecks, pre_spaces, processed, read_files, reg, rules, sizeOf, spaces, tag, tagFound, tag_found_test, total_return, val, z_index, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m;
    read_files = getFiles(args);
    switch (command) {
      case 'simple_lint':
        config = args[1];
        if (config == null) {
          config = {
            bad_indent: 'Bad spacing! should me a multiple of 2 spaces',
            comment_space: '// must have a space after',
            star_selector: '* is HORRIBLE performance please use a different selector',
            zero_px: 'Don\'t need px on 0 values',
            no_colon_semicolon: 'No ; or : in stylus file!',
            comma_space: ', must have a space after',
            alphabetize_check: 'This area needs to be alphabetized',
            dupe_tag_check: 'Duplicate tags found.. please consolidate',
            style_attribute_check: 'Invalid Attribute!'
          };
        }
        files = {};
        addError = function(msg, line, line_num, file) {
          if (files[file] == null) {
            files[file] = [];
          }
          return files[file].push({
            message: msg,
            line: line,
            line_num: line_num
          });
        };
        preJsonChecks = function() {
          var bad_indent, check_1, check_2, comment_space, data, file, line, line_num, spaces, zero_px, _i, _len, _ref, _results;
          _ref = config || {}, bad_indent = _ref.bad_indent, comment_space = _ref.comment_space, zero_px = _ref.zero_px;
          _results = [];
          for (_i = 0, _len = read_files.length; _i < _len; _i++) {
            file = read_files[_i];
            if (!(/.styl/.test(file))) {
              continue;
            }
            data = fs.readFileSync(file, 'utf8');
            data = data.split('\n');
            _results.push((function() {
              var _j, _len1, _results1;
              _results1 = [];
              for (line_num = _j = 0, _len1 = data.length; _j < _len1; line_num = ++_j) {
                line = data[line_num];
                if (bad_indent) {
                  spaces = getPreSpaces(line);
                  if (spaces % 2) {
                    addError(bad_indent, line, line_num + 1, file);
                  }
                }
                if (comment_space) {
                  check_1 = /^\s*\/\//.test(line);
                  check_2 = /\/\/\s/.test(line);
                  if (check_1 && !check_2) {
                    addError(comment_space, line, line_num + 1, file);
                  }
                }
                if (zero_px) {
                  if (/\s0px/.test(line)) {
                    _results1.push(addError(zero_px, line, line_num + 1, file));
                  } else {
                    _results1.push(void 0);
                  }
                } else {
                  _results1.push(void 0);
                }
              }
              return _results1;
            })());
          }
          return _results;
        };
        postJsonChecks = function() {
          var arr, att, attribute, attribute_info, check_1, check_2, comma_space, data, dupe, dupe_tag_check, file, file_name, index, key, line, line_num, lines, no_colon_semicolon, pair, s_ac, star_selector, style_attribute_check, stylus_stags, tag, total_tags, _i, _j, _len, _len1, _name, _ref, _ref1, _results;
          data = processData('convertStyleToJson', args);
          stylus_stags = [];
          total_tags = {};
          if (config == null) {
            config = {};
          }
          star_selector = config.star_selector, style_attribute_check = config.style_attribute_check, no_colon_semicolon = config.no_colon_semicolon;
          comma_space = config.comma_space, dupe_tag_check = config.dupe_tag_check;
          _results = [];
          for (file_name in data) {
            file = data[file_name];
            for (line_num in file) {
              attribute_info = file[line_num];
              if (attribute_info.tag === '') {
                continue;
              }
              line = parseInt(line_num, 10);
              if (total_tags[_name = attribute_info.tag] == null) {
                total_tags[_name] = [];
              }
              total_tags[attribute_info.tag].push(line - 1);
              if (star_selector) {
                if (/\*/.test(attribute_info.tag)) {
                  addError(star_selector, attribute_info.tag, line_num - 1, file_name);
                }
              }
              _ref = attribute_info.rules;
              for (key = _i = 0, _len = _ref.length; _i < _len; key = ++_i) {
                attribute = _ref[key];
                if (style_attribute_check) {
                  att = attribute.trim();
                  pair = att.split(' ');
                  if ((pair != null ? pair.length : void 0) === 2 && valid_selectors[pair[0]]) {
                    if (_ref1 = pair[1], __indexOf.call(valid_selectors[pair[0]], _ref1) < 0) {
                      s_ac = style_attribute_check;
                      addError(s_ac, attribute, line + key - 1, file_name);
                    }
                  }
                }
                if (no_colon_semicolon) {
                  if (/;|:/.test(attribute)) {
                    addError(no_colon_semicolon, attribute, line + key - 1, file_name);
                  }
                }
                if (comma_space) {
                  check_1 = attribute.match(/,/g);
                  check_2 = attribute.match(/,\s/g);
                  if ((check_1 != null ? check_1.length : void 0) !== (check_2 != null ? check_2.length : void 0)) {
                    addError(comma_space, attribute, line + key - 1, file_name);
                  }
                }
              }
            }
            if (dupe_tag_check) {
              for (tag in total_tags) {
                arr = total_tags[tag];
                if (arr.length > 1) {
                  lines = arr.join(',');
                  for (index = _j = 0, _len1 = arr.length; _j < _len1; index = ++_j) {
                    dupe = arr[index];
                    addError(dupe_tag_check, tag, dupe, file_name);
                  }
                }
              }
              _results.push(total_tags = []);
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        };
        alphabetizeCheck = function() {
          var alphabetize_check, file_name, infraction, key, line, line_number, return_data, _i, _len, _ref, _ref1, _results;
          alphabetize_check = (config || {}).alphabetize_check;
          if (alphabetize_check) {
            return_data = processData('checkAlphabetized', args);
            if (return_data.infractions == null) {
              return_data.infractions = [];
            }
            _ref = return_data.infractions;
            _results = [];
            for (key = _i = 0, _len = _ref.length; _i < _len; key = ++_i) {
              infraction = _ref[key];
              _ref1 = infraction || {}, line = _ref1.line, line_number = _ref1.line_number, file_name = _ref1.file_name;
              _results.push(addError(alphabetize_check, line, line_number, file_name));
            }
            return _results;
          }
        };
        preJsonChecks();
        postJsonChecks();
        alphabetizeCheck();
        return files;
      case 'checkAlphabetized':
        infractions = [];
        data = processData('convertStyleToJson', args);
        for (file_name in data) {
          file = data[file_name];
          for (tag in file) {
            attribute_info = file[tag];
            rules = attribute_info.rules;
            if (!alphabetize(rules)) {
              continue;
            }
            infractions.push({
              line_number: tag,
              line: rules[0],
              file_name: file_name
            });
          }
        }
        if (infractions.length) {
          return {
            alphabetized: false,
            infractions: infractions
          };
        }
        return {
          alphabetized: true
        };
      case 'alphabetizeStyle':
        data = processData('convertStyleToJson', args);
        for (file_name in data) {
          file = data[file_name];
          for (index in file) {
            attribute_info = file[index];
            rules = attribute_info.rules, indent = attribute_info.indent;
            if (!alphabetize(rules)) {
              continue;
            }
            spaces = Array(parseInt(indent) + 1).join(' ');
            for (line_num = _i = 0, _len = rules.length; _i < _len; line_num = ++_i) {
              attr = rules[line_num];
              line = parseInt(index) + parseInt(line_num, 10);
              writeToLine(file_name, "" + spaces + attr, line);
            }
          }
        }
        return processData('checkAlphabetized', args);
      case 'convertStyleToJson':
        total_return = {};
        processed = 0;
        join = function(data_1, data_2) {
          var arg1, arg2, arr_1, arr_2, str, _j, _k, _len1, _len2;
          arr_1 = data_1.split(',');
          arr_2 = data_2.split(',');
          str = [];
          for (_j = 0, _len1 = arr_1.length; _j < _len1; _j++) {
            arg1 = arr_1[_j];
            for (_k = 0, _len2 = arr_2.length; _k < _len2; _k++) {
              arg2 = arr_2[_k];
              str.push("" + (arg1.trim()) + " " + (arg2.trim()));
            }
          }
          return str.join(', ');
        };
        for (_j = 0, _len1 = read_files.length; _j < _len1; _j++) {
          file = read_files[_j];
          if (!/.styl/.test(file)) {
            continue;
          }
          obj = {};
          tag_found_test = /((\n|^)(\s)*(\.|&|>|#|@media).+)|(\n|^)(\s)*(table|td|th|tr|div|span|a|h1|h2|h3|h4|h5|h6|strong|em|quote|form|fieldset|label|input|textarea|button|body|img|ul|li|html|object|iframe|p|blockquote|abbr|address|cite|del|dfn|ins|kbd|q|samp|sup|var|b|i|dl|dt|dd|ol|legend|caption|tbody|tfoot|thead|article|aside|canvas|details|figcaption|figure|footer|header|hgroup|menu|nav|section|summary|time|mark|audio|video)(,| |\.|$).*/;
          data = fs.readFileSync(file, 'utf8', function(err, data) {});
          data = data.split('\n');
          tagFound = false;
          attributeSet = [];
          tag = '';
          indent = 0;
          for (line_num in data) {
            line = data[line_num];
            if (line.match(/^\s*$/)) {
              continue;
            }
            if (line.match(tag_found_test)) {
              tagFound = true;
              if (attributeSet.length) {
                line_number = parseInt(line_num, 10) + 1 - attributeSet.length;
                obj[line_number] = {
                  indent: indent,
                  rules: attributeSet,
                  tag: tag.trim()
                };
                attributeSet = [];
                indent = 0;
              }
              if (getPreSpaces(line) > getPreSpaces(tag)) {
                tag = join(tag, line.trim());
              } else {
                tag = line;
              }
            } else if (tagFound) {
              pre_spaces = getPreSpaces(line);
              if (indent === 0) {
                indent = pre_spaces;
                if (indent === 0) {
                  continue;
                }
              }
              if (indent === pre_spaces) {
                attributeSet.push("" + (line.trim()));
              } else {
                line_number = parseInt(line_num, 10) - attributeSet.length;
                obj[line_number] = {
                  indent: indent,
                  rules: attributeSet,
                  tag: tag.trim()
                };
                tag = '';
                attributeSet = [];
                indent = 0;
              }
            }
          }
          total_return[file] = obj;
        }
        return total_return;
      case 'inspectZValues':
        filesTotal = {};
        for (_k = 0, _len2 = read_files.length; _k < _len2; _k++) {
          file = read_files[_k];
          if (/.styl/.test(file)) {
            data = fs.readFileSync("" + file, 'utf8');
            arr = data.match(/(z-index:? +)([0-9]+)/g);
            if (arr != null ? arr.length : void 0) {
              for (_l = 0, _len3 = arr.length; _l < _len3; _l++) {
                val = arr[_l];
                val = val.match(/(z-index:? +)([0-9]+)/);
                z_index = parseInt(val[2], 10);
                if (filesTotal[z_index] == null) {
                  filesTotal[z_index] = [];
                }
                filesTotal[z_index].push(file);
              }
            }
          }
        }
        return filesTotal;
      case 'normalizeZvalues':
        sizeOf = function(obj) {
          var key, size;
          size = 0;
          for (key in obj) {
            val = obj[key];
            size++;
          }
          return size;
        };
        filesTotal = processData('inspectZValues', args);
        count = null;
        breathing_room = args[1] || 10;
        for (z_index in filesTotal) {
          files = filesTotal[z_index];
          z_index = parseInt(z_index, 10);
          if (count == null) {
            count = Math.min(z_index, 1);
          }
          if (z_index !== count) {
            for (_m = 0, _len4 = files.length; _m < _len4; _m++) {
              file = files[_m];
              buf = fs.readFileSync("" + file, 'utf8');
              reg = new RegExp("z-index:? +" + z_index + "\n", 'g');
              buf = buf.replace(reg, "z-index " + count + "\n");
              fs.writeFileSync("" + file, buf, 'utf8');
            }
          }
          count += breathing_room;
        }
        filesTotal = processData('inspectZValues', args);
        return filesTotal;
      default:
        return false;
    }
  };

  if (/stylus-help/.test(typeof module !== "undefined" && module !== null ? (_ref = module.parent) != null ? _ref.filename : void 0 : void 0)) {
    value = processData(command, args);
    if (value) {
      value = JSON.stringify(value, null, 3);
      log(value);
    } else {
      log("invalid command " + command);
      log(USAGE);
    }
  }

  exports.processData = processData;

}).call(this);
