// Generated by CoffeeScript 1.7.1
(function() {
  var USAGE, alphabetize, args, argv, async, command, exit, filePath, fs, getFiles, getPreSpaces, log, optimist, opts, path, processData, valid_selectors, value, writeToLine, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  async = require('async');

  optimist = require('optimist');

  path = require('path');

  filePath = path.join(__dirname, 'valid_selectors.json');

  valid_selectors = JSON.parse(fs.readFileSync(filePath, 'utf8'));

  USAGE = "Usage: styler <command> [command-specific-options]\n\nwhere <command> [command-specific-options] is one of:\n  alphabetizeStyle <path to stylus dir or file>\n  checkAlphabetized <path to stylus dir or file>\n  convertStyleToJson <path to stylus dir or file> (note need to > to json write to console)\n  inspectZValues <path to stylus dir or file>\n  normalizeZvalues <path to stylus dir or file>, [value to normalize on]\n  simple_lint <path to stylus dir or file>";

  argv = optimist.argv._;

  command = argv[0];

  args = argv.slice(1, argv.length);

  opts = optimist.argv;

  exit = function(msg) {
    if (msg == null) {
      msg = 'bye';
    }
    if (msg) {
      log(msg);
    }
    return process.exit();
  };

  log = function(msg) {
    var c;
    c = console;
    return c.log(msg);
  };

  getPreSpaces = function(str) {
    return str.match(/^(\s)*/)[0].length;
  };

  writeToLine = function(file, line_str, line_num) {
    var data, end_line, file_str, line, line_number;
    file_str = '';
    data = fs.readFileSync(file, 'utf8');
    data = data.split('\n');
    for (line_number in data) {
      line = data[line_number];
      end_line = '';
      if (line_number === ("" + (line_num - 1))) {
        line = line_str;
      }
      if (("" + (data.length - 1)) !== line_number) {
        end_line = '\n';
      }
      file_str += "" + line + end_line;
    }
    return fs.writeFileSync(file, file_str, 'utf8');
  };

  alphabetize = function(data) {
    var arrayEqual, old_data;
    old_data = data.slice(0);
    data.sort();
    arrayEqual = function(a, b) {
      return a.length === b.length && a.every(function(elem, i) {
        return elem === b[i];
      });
    };
    return !arrayEqual(old_data, data);
  };

  getFiles = function(args, next) {
    var key, read_files, stats, type, val;
    type = '';
    if (!args.length) {
      return [];
    }
    stats = fs.statSync(args[0]);
    if (stats.isDirectory()) {
      type = 'directory';
      read_files = fs.readdirSync(args[0]);
      for (key in read_files) {
        val = read_files[key];
        read_files[key] = args[0] + read_files[key];
      }
    } else if (stats.isFile()) {
      type = 'file';
      read_files = [args[0]];
    }
    return read_files;
  };

  processData = function(command, args) {
    var addError, alphabetizeCheck, attr, attributeSet, attribute_info, breathing_room, buf, config, count, data, errors, file, file_name, files, filesTotal, generateJson, indent, index, join, line, line_num, line_number, obj, postJsonChecks, preJsonChecks, pre_spaces, processed, read_files, reg, return_data, sizeOf, space_num, spaces, tag, tagFound, total_return, z_index, _i, _j, _k, _len, _len1, _len2, _ref;
    read_files = getFiles(args);
    switch (command) {
      case 'simple_lint':
        config = args[1];
        if (config == null) {
          config = {
            bad_indent: 'Bad spacing! should me a multiple of 2 spaces',
            comment_space: '// must have a space after',
            star_selector: '* is HORRIBLE performance please use a different selector',
            zero_px: 'Don\'t need px on 0 values',
            no_colon_semicolon: 'No ; or : in stylus file!',
            comma_space: ', must have a space after',
            alphabetize_check: 'This area needs to be alphabetized',
            dupe_tag_check: 'Duplicate tags found.. please consolidate',
            style_attribute_check: 'Invalid Attribute!'
          };
        }
        errors = [];
        addError = function(msg, line, line_num) {
          return errors.push({
            message: msg,
            line: line,
            line_num: line_num
          });
        };
        preJsonChecks = function() {
          var check_1, check_2, data, file, line, line_num, spaces, _i, _j, _len, _len1;
          for (_i = 0, _len = read_files.length; _i < _len; _i++) {
            file = read_files[_i];
            if (!(/.styl/.test(file))) {
              data_next();
              return;
            }
            data = fs.readFileSync(file, 'utf8');
            data = data.split('\n');
            for (line_num = _j = 0, _len1 = data.length; _j < _len1; line_num = ++_j) {
              line = data[line_num];
              if (config.bad_indent) {
                spaces = getPreSpaces(line);
                if ((spaces % 2) !== 0) {
                  addError(config != null ? config.bad_indent : void 0, line, line_num + 1);
                }
              }
              if (config != null ? config.comment_space : void 0) {
                check_1 = /^\s*\/\//.test(line);
                check_2 = /\/\/\s/.test(line);
                if (check_1 && !check_2) {
                  addError(config != null ? config.comment_space : void 0, line, line_num + 1);
                }
              }
              if (config.zero_px) {
                if (/\s0px/.test(line)) {
                  addError(config.zero_px, line, line_num + 1);
                }
              }
            }
          }
        };
        postJsonChecks = function() {
          var arr, att, attribute, attribute_info, check_1, check_2, data, dupe, file, file_name, index, key, line, line_num, lines, pair, s_ac, stylus_stags, tag, total_tags, _i, _len, _name, _ref, _ref1, _results;
          data = processData('convertStyleToJson', args);
          stylus_stags = [];
          total_tags = {};
          for (file_name in data) {
            file = data[file_name];
            for (line_num in file) {
              attribute_info = file[line_num];
              if (attribute_info.tag === '') {
                continue;
              }
              line = parseInt(line_num, 10);
              if (total_tags[_name = attribute_info.tag] == null) {
                total_tags[_name] = [];
              }
              total_tags[attribute_info.tag].push(line - 1);
              if (config.star_selector) {
                if (/\*/.test(attribute_info.tag)) {
                  addError(config.star_selector, attribute_info.tag, line_num);
                }
              }
              _ref = attribute_info.rules;
              for (key = _i = 0, _len = _ref.length; _i < _len; key = ++_i) {
                attribute = _ref[key];
                if (config.style_attribute_check) {
                  att = attribute.trim();
                  pair = att.split(' ');
                  if ((pair != null ? pair.length : void 0) === 2 && valid_selectors[pair[0]]) {
                    if (_ref1 = pair[1], __indexOf.call(valid_selectors[pair[0]], _ref1) < 0) {
                      s_ac = config.style_attribute_check;
                      addError(s_ac, attribute, line + key - 1);
                    }
                  }
                }
                if (config.no_colon_semicolon) {
                  if (/;|:/.test(attribute)) {
                    addError(config.no_colon_semicolon, attribute, line + key - 1);
                  }
                }
                if (config.comma_space) {
                  check_1 = attribute.match(/,/g);
                  check_2 = attribute.match(/,\s/g);
                  if ((check_1 != null ? check_1.length : void 0) !== (check_2 != null ? check_2.length : void 0)) {
                    addError(config.comma_space, attribute, line + key - 1);
                  }
                }
              }
            }
          }
          if (config.dupe_tag_check) {
            _results = [];
            for (tag in total_tags) {
              arr = total_tags[tag];
              if (arr.length > 1) {
                lines = arr.join(',');
                _results.push((function() {
                  var _j, _len1, _results1;
                  _results1 = [];
                  for (index = _j = 0, _len1 = arr.length; _j < _len1; index = ++_j) {
                    dupe = arr[index];
                    _results1.push(addError(config.dupe_tag_check, tag, dupe));
                  }
                  return _results1;
                })());
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          }
        };
        alphabetizeCheck = function() {
          var a_c, i_l, i_ln, infraction, key, return_data, _i, _len, _ref, _results;
          if (config.alphabetize_check) {
            return_data = processData('checkAlphabetized', args);
            if (return_data.infractions == null) {
              return_data.infractions = [];
            }
            _ref = return_data.infractions;
            _results = [];
            for (key = _i = 0, _len = _ref.length; _i < _len; key = ++_i) {
              infraction = _ref[key];
              a_c = config.alphabetize_check;
              i_l = infraction.line;
              i_ln = infraction.line_number;
              _results.push(addError(a_c, i_l, i_ln));
            }
            return _results;
          }
        };
        preJsonChecks();
        postJsonChecks();
        alphabetizeCheck();
        return errors;
      case 'checkAlphabetized':
        return_data = null;
        data = processData('convertStyleToJson', args);
        for (file_name in data) {
          file = data[file_name];
          for (tag in file) {
            attribute_info = file[tag];
            if (alphabetize(attribute_info.rules)) {
              if (return_data == null) {
                return_data = {
                  alphabetized: false,
                  infractions: []
                };
              }
              return_data.infractions.push({
                line_number: tag,
                line: attribute_info.rules[0],
                file_name: file_name
              });
            }
          }
        }
        if (return_data == null) {
          return_data = {
            alphabetized: true
          };
        }
        return return_data;
      case 'alphabetizeStyle':
        data = processData('convertStyleToJson', args);
        for (file_name in data) {
          file = data[file_name];
          for (index in file) {
            attribute_info = file[index];
            if (alphabetize(attribute_info.rules)) {
              space_num = attribute_info.indent;
              spaces = Array(parseInt(space_num + 1)).join(' ');
              _ref = attribute_info.rules;
              for (line_num = _i = 0, _len = _ref.length; _i < _len; line_num = ++_i) {
                attr = _ref[line_num];
                line = parseInt(index, 10) + parseInt(line_num, 10);
                writeToLine(file_name, "" + spaces + attr, line);
              }
            }
          }
        }
        return processData('checkAlphabetized', args);
      case 'convertStyleToJson':
        join = function(data_1, data_2) {
          var arg1, arg2, arr_1, arr_2, str, _j, _k, _len1, _len2;
          arr_1 = data_1.split(',');
          arr_2 = data_2.split(',');
          str = [];
          for (_j = 0, _len1 = arr_1.length; _j < _len1; _j++) {
            arg1 = arr_1[_j];
            for (_k = 0, _len2 = arr_2.length; _k < _len2; _k++) {
              arg2 = arr_2[_k];
              str.push("" + (arg1.trim()) + " " + (arg2.trim()));
            }
          }
          return str.join(', ');
        };
        total_return = {};
        processed = 0;
        for (_j = 0, _len1 = read_files.length; _j < _len1; _j++) {
          file = read_files[_j];
          obj = {};
          if (!(/.styl/.test(file))) {
            continue;
          }
          data = fs.readFileSync(file, 'utf8', function(err, data) {});
          data = data.split('\n');
          tagFound = false;
          attributeSet = [];
          tag = '';
          indent = 0;
          for (line_num in data) {
            line = data[line_num];
            if (line.match(/^\s*$/)) {
              continue;
            }
            if (line.match(/((\n|^)(\s)*(\.|&|>|#|@media).+)|(\n|^)(\s)*(table|td|th|tr|div|span|a|h1|h2|h3|h4|h5|h6|strong|em|quote|form|fieldset|label|input|textarea|button|body|img|ul|li|html|object|iframe|p|blockquote|abbr|address|cite|del|dfn|ins|kbd|q|samp|sup|var|b|i|dl|dt|dd|ol|legend|caption|tbody|tfoot|thead|article|aside|canvas|details|figcaption|figure|footer|header|hgroup|menu|nav|section|summary|time|mark|audio|video)(,| |\.|$).*/)) {
              tagFound = true;
              if (attributeSet.length) {
                line_number = parseInt(line_num, 10) + 1 - attributeSet.length;
                obj[line_number] = {
                  indent: indent,
                  rules: attributeSet
                };
                obj[line_number].tag = tag.trim();
                attributeSet = [];
                indent = 0;
              }
              if (getPreSpaces(line) > getPreSpaces(tag)) {
                tag = join(tag, line.trim());
              } else {
                tag = line;
              }
            } else if (tagFound) {
              pre_spaces = getPreSpaces(line);
              if (indent === 0) {
                indent = pre_spaces;
                if (indent === 0) {
                  continue;
                }
              }
              if (indent === pre_spaces) {
                attributeSet.push("" + (line.trim()));
              } else {
                line_number = parseInt(line_num, 10) - attributeSet.length;
                obj[line_number] = {
                  indent: indent,
                  rules: attributeSet
                };
                obj[line_number].tag = tag.trim();
                tag = '';
                attributeSet = [];
                indent = 0;
              }
            }
          }
          total_return[file] = obj;
        }
        return total_return;
      case 'inspectZValues':
        generateJson = function(doneJson) {
          var addFile, filesTotal, _k, _len2, _results;
          processed = 1;
          filesTotal = {};
          _results = [];
          for (_k = 0, _len2 = read_files.length; _k < _len2; _k++) {
            file = read_files[_k];
            addFile = function(file) {
              var arr, val, z_index, _l, _len3;
              if (/.styl/.test(file)) {
                data = fs.readFileSync("" + file, 'utf8');
                arr = data.match(/(z-index:? +)([0-9]+)/g);
                if (arr != null ? arr.length : void 0) {
                  for (_l = 0, _len3 = arr.length; _l < _len3; _l++) {
                    val = arr[_l];
                    val = val.match(/(z-index:? +)([0-9]+)/);
                    z_index = parseInt(val[2], 10);
                    if (filesTotal[z_index] == null) {
                      filesTotal[z_index] = [];
                    }
                    filesTotal[z_index].push(file);
                  }
                  return data_next();
                }
              }
            };
            _results.push(addFile(file));
          }
          return _results;
        };
        return generateJson(filesTotal);
      case 'normalizeZvalues':
        sizeOf = function(obj) {
          var key, size, val;
          size = 0;
          for (key in obj) {
            val = obj[key];
            size++;
          }
          return size;
        };
        filesTotal = processData('inspectZValues', args);
        count = null;
        breathing_room = args[1];
        if (breathing_room == null) {
          breathing_room = 10;
        }
        for (z_index in filesTotal) {
          files = filesTotal[z_index];
          z_index = parseInt(z_index, 10);
          if (count == null) {
            count = Math.min(z_index, 1);
          }
          if (z_index !== count) {
            for (_k = 0, _len2 = files.length; _k < _len2; _k++) {
              file = files[_k];
              buf = fs.readFileSync("" + file, 'utf8');
              reg = new RegExp("z-index:? +" + z_index + "\n", 'g');
              buf = buf.replace(reg, "z-index " + count + "\n");
              fs.writeFileSync("" + file, buf, 'utf8');
            }
          }
          count += breathing_room;
        }
        filesTotal = processData('inspectZValues', args);
        return filesTotal;
      default:
        return false;
    }
  };

  if (/stylus-help/.test(typeof module !== "undefined" && module !== null ? (_ref = module.parent) != null ? _ref.filename : void 0 : void 0)) {
    value = processData(command, args);
    if (value) {
      value = JSON.stringify(value, null, 3);
      log(value);
    } else {
      log("invalid command " + command);
      log(USAGE);
    }
  }

  exports.processData = processData;

}).call(this);
